extends Node
class_name Packet

# =============================================================================
# Packet.gd
# =============================================================================
# LONG DESCRIPTION:
# This module defines the "wire format" for client->server input commands.
#
# Why this exists:
# - Dictionaries of Variants are convenient but:
#     * larger on the wire (string keys + Variant type tags)
#     * slower to serialize/deserialize
#     * harder to validate strictly
# - Fixed byte layouts are:
#     * compact
#     * fast
#     * easy to version/validate
#
# This file is intentionally PURE encode/decode:
# - no networking (no .rpc calls)
# - no gameplay logic
# - no scene nodes
#
# It should be safe to use from both server and client code.
# =============================================================================

# -----------------------------------------------------------------------------
# Input packet constants
# -----------------------------------------------------------------------------

# Total bytes in an input command packet.
const INPUT_PACKET_SIZE: int = 8

# Reserve the top bit of buttons to mean "aim angle is valid".
# Lower bits are available for your gameplay button bitmask.
const AIM_VALID_MASK: int = 0x8000

# Quantization scale for normalized movement components:
# -1.0..1.0 mapped to -127..127
const MOVE_Q: float = 127.0

# Angle quantization: 0..TAU mapped to 0..65535
const ANGLE_Q: float = 65535.0


# =============================================================================
# InputCmd (typed structure)
# =============================================================================
# Godot doesn't have C-style structs, but a small RefCounted class works well.
# You can pass this around internally on server/client without using dictionaries.
class InputCmd extends RefCounted:
	var seq: int = 0          # 0..65535
	var buttons: int = 0      # 0..65535 (bitmask)
	var mv: Vector2 = Vector2.ZERO   # normalized-ish move input
	var aim: Vector2 = Vector2.ZERO  # unit vector or ZERO


# -----------------------------------------------------------------------------
# make_empty_input()
# -----------------------------------------------------------------------------
# PURPOSE:
# - Convenience for "no input yet" placeholders on server.
#
# WHERE CALLED:
# - ServerMain when initializing per-peer input state on connect.
#
# RETURNS:
# - InputCmd with seq=0 and zero vectors.
# -----------------------------------------------------------------------------
static func make_empty_input() -> InputCmd:
	return InputCmd.new()


# -----------------------------------------------------------------------------
# pack_input(seq, mv, aim, buttons)
# -----------------------------------------------------------------------------
# PURPOSE:
# - Convert a typed input command into a compact PackedByteArray (8 bytes).
#
# WHERE CALLED:
# - ClientMain every tick to send inputs to the server:
#     Net.server_receive_input_bytes.rpc_id(1, Packet.pack_input(...))
#
# PARAMETERS:
# - seq: monotonically increasing input sequence number (client-local)
# - mv: movement vector (recommended normalized)
# - aim: aim direction vector (unit length recommended); if zero, aim flag is off
# - buttons: gameplay bitmask. NOTE: we will override bit 15 for "aim valid".
#
# RETURNS:
# - PackedByteArray exactly INPUT_PACKET_SIZE bytes long.
#
# WHY:
# - This is the "on the wire" representation, minimizing packet size.
# -----------------------------------------------------------------------------
static func pack_input(seq: int, mv: Vector2, aim: Vector2, buttons: int) -> PackedByteArray:
	var buf := StreamPeerBuffer.new()
	buf.big_endian = false # Little-endian for consistency.

	# Clamp seq and buttons into 16-bit ranges.
	var seq_u16: int = seq & 0xFFFF

	# We'll store aim-valid in the top bit (0x8000).
	# Keep only the lower 15 bits for gameplay.
	var btn_u16: int = buttons & 0x7FFF

	# Quantize movement components into signed int8.
	var mvx_i8: int = int(round(clamp(mv.x, -1.0, 1.0) * MOVE_Q))
	var mvy_i8: int = int(round(clamp(mv.y, -1.0, 1.0) * MOVE_Q))

	# Aim: encode as angle if aim is non-zero.
	var aim_valid := aim.length() > 0.001
	var angle_u16: int = 0

	if aim_valid:
		btn_u16 |= AIM_VALID_MASK

		# Convert aim vector to angle in radians [0, TAU).
		var ang: float = aim.angle()
		ang = fposmod(ang, TAU)

		# Quantize to 0..65535
		angle_u16 = int(round((ang / TAU) * ANGLE_Q)) & 0xFFFF

	# Write fields in fixed order:
	# seq (u16), buttons (u16), mv_x (i8), mv_y (i8), aim_angle (u16)
	buf.put_u16(seq_u16)
	buf.put_u16(btn_u16)
	buf.put_8(mvx_i8)     # signed int8
	buf.put_8(mvy_i8)     # signed int8
	buf.put_u16(angle_u16)

	# Extract bytes
	var out: PackedByteArray = buf.data_array

	# Safety: ensure size is exactly what we expect.
	# (If this fails, something changed in the pack layout.)
	if out.size() != INPUT_PACKET_SIZE:
		# Force correct size; in practice this should not happen.
		out.resize(INPUT_PACKET_SIZE)

	return out


# -----------------------------------------------------------------------------
# unpack_input(data)
# -----------------------------------------------------------------------------
# PURPOSE:
# - Parse an 8-byte PackedByteArray into a typed InputCmd.
#
# WHERE CALLED:
# - Server (Net RPC endpoint) when receiving client input packets.
# - Could also be used client-side for debugging/tests.
#
# PARAMETERS:
# - data: PackedByteArray expected to be INPUT_PACKET_SIZE bytes.
#
# RETURNS:
# - InputCmd:
#     seq, buttons, mv (float vector), aim (unit vector or ZERO)
#
# VALIDATION:
# - If packet size is wrong, returns an "empty" InputCmd (seq=0).
#
# WHY:
# - Centralizes wire format parsing and type conversions.
# -----------------------------------------------------------------------------
static func unpack_input(data: PackedByteArray) -> InputCmd:
	var cmd := InputCmd.new()

	if data.size() != INPUT_PACKET_SIZE:
		# Invalid size; return empty cmd.
		return cmd

	var buf := StreamPeerBuffer.new()
	buf.big_endian = false
	buf.data_array = data
	buf.seek(0)

	var seq_u16: int = int(buf.get_u16())
	var btn_u16: int = int(buf.get_u16())

	# get_8 returns signed int (-128..127).
	var mvx_i8: int = int(buf.get_8())
	var mvy_i8: int = int(buf.get_8())

	var angle_u16: int = int(buf.get_u16())

	cmd.seq = seq_u16
	cmd.buttons = btn_u16

	# Dequantize movement back into floats roughly -1..1
	cmd.mv = Vector2(float(mvx_i8) / MOVE_Q, float(mvy_i8) / MOVE_Q)

	# Aim only valid if flag set.
	if (btn_u16 & AIM_VALID_MASK) != 0:
		var ang: float = (float(angle_u16) / ANGLE_Q) * TAU
		cmd.aim = Vector2(cos(ang), sin(ang))
	else:
		cmd.aim = Vector2.ZERO

	return cmd
